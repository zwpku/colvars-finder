"""Trajectory Data --- :mod:`colvarsfinder.utils`
=================================================================

:Author: Wei Zhang
:Year: 2022
:Copyright: GNU Public License v3

This module implements a class that defines a feature of molecular system
(:class:`molann.feature.Feature`), and a class that constructs a list of
features from a feature file (:class:`molann.feature.FeatureFileReader`).

Classes
-------
.. autoclass:: WeightedTrajectory
    :members:

Functions
---------

.. autofunction:: integrate_langevin

.. autofunction:: calc_weights

"""


import math
from random import random, randint
import numpy as np
import time
import datetime
import os, sys
import warnings
from sys import stdout
import pandas as pd
import MDAnalysis as mda
import torch

# import openmm
from openmm import *
from openmm.app import *

# ### MD simulation

class WeightedTrajectory(object):
    r"""Class that stores trajectory data.

    Args:

        universe (:external+mdanalysis:class:`MDAnalysis.universe`): universe that contains trajectory data
        weight_filename (str): filename of a csv file that contains
            weights of trajectory. This file can be generated by running :meth:`integrate_langevin`.
        min_w (float): minimal value of weights below which the corresponding states will be discarded.
        max_w (float): maximal value of weights above which the corresponding states will be discarded.
        verbose (bool): print more information if ture.

    Attributes
    ----------

    Example
    -------
    """
    def __init__(self, universe, weight_filename=None, min_w=0.0, max_w=1e10, verbose=True):

        if verbose: print ('\nloading trajectory to numpy array...', end='') 

        # load trajectory 
        self.trajectory = universe.trajectory.timeseries(order='fac')

        if verbose: print ('done.') 

        self.start_time = universe.trajectory.time
        self.dt = universe.trajectory.dt
        self.n_frames = universe.trajectory.n_frames

        # print information of trajectory
        if verbose: 
            print ('\nTrajectory Info:\n' \
                   '  no. of frames in trajectory data: {}\n' \
                   '  time of first frame: {:.1f}ps\n'\
                   '  time of last frame: {:.1f}ps\n'\
                   '  stepsize: {:.1f}ps\n' \
                   '  time length: {:.1f}ps\n'\
                   '  shape of trajectory data array: {}\n'.format(self.n_frames, 
                                                                   self.start_time, 
                                                                   universe.trajectory[-1].time,
                                                                   self.dt, 
                                                                   universe.trajectory.totaltime,
                                                                   self.trajectory.shape
                                                                )
                  )

        if weight_filename :

            time_weight_vec = pd.read_csv(weight_filename)
            # normalize
            time_weight_vec['weight'] /= time_weight_vec['weight'].mean()

            if verbose: 
                print ('\nloading weights from file: ', weight_filename)
                print ('\nWeights:\n', time_weight_vec['weight'].describe(percentiles=[0.2, 0.4, 0.6, 0.8]))

            if self.start_time - time_weight_vec.iloc[0,0] > 0.01 or self.n_frames != len(time_weight_vec.index) :
                raise ValueError('Time in weight file does match the trajectory data!\n')
            else :
                if verbose: print ('\nCompatibility of weights and trajectory verified.\n')

            selected_idx = (time_weight_vec['weight'] > min_w) & (time_weight_vec['weight'] < max_w)
            weights = time_weight_vec[selected_idx].copy()

            self.trajectory = self.trajectory[selected_idx,:,:]

            weights['weight'] /= weights['weight'].mean()

            if verbose: 
                print ('\nAfter selecting states whose weights are in [{:.3e}, {:.3e}] and renormalization:\n' \
                       '\nShape of trajectory: {}'.format(min_w, max_w, self.trajectory.shape)
                      )
                print ('\nWeights:\n', weights['weight'].describe(percentiles=[0.2, 0.4, 0.6, 0.8]))

            self.weights = weights['weight'].to_numpy()
        else :
            self.weights = np.ones(self.n_frames)

# Generate MD trajectory data using OpenMM 
def integrate_langevin(pdb_filename, n_steps, sampling_temp, sampling_path, pre_steps=0, step_size=1.0 * unit.femtoseconds,
        frictionCoeff=1.0 / unit.picosecond,  traj_dcd_filename='traj.dcd', csv_filename='output.csv', report_interval_dcd=100,
        report_interval_stdout=100, report_interval_csv=100, forcefield=None, plumed_script=None):
    r"""Generate trajectory data by integrating Langevin dynamics

    Args:
        sampling_temp (int): temperature used in sampling states
        csv_filename (str): filename of the csv file to store outputs 
        traj_weight_filename (str): filename to output the trajectory weights
        energy_col_idx (int): column index of the file csv_filename that will be used to calcuate weights

    """

    print (f'\nSampling temperature: {sampling_temp}')
    print ( 'Directory to save trajectory ouptuts: %s' % sampling_path)

    # add path to filenames
    traj_dcd_filename = os.path.join(sampling_path, traj_dcd_filename)
    csv_filename=os.path.join(sampling_path, csv_filename)

    # prepare before simulation
    pdb = PDBFile(pdb_filename)

    if forcefield is None :
        forcefield = ForceField('amber14-all.xml')

    system = forcefield.createSystem(pdb.topology, nonbondedCutoff=2*unit.nanometer, constraints=HBonds)

    if plumed_script is not None :
        from openmmplumed import PlumedForce
        print ('plumed script: %s' % plumed_script)
        system.addForce(PlumedForce(plumed_script))

    integrator = LangevinIntegrator(sampling_temp, frictionCoeff, step_size)

    simulation = Simulation(pdb.topology, system, integrator)
    simulation.context.setPositions(pdb.positions)

    platform = simulation.context.getPlatform()
    print ("\nUsing OpenMM platform: %s\n" % platform.getName())

    print ('\nStep 1: Energy minimization...', end='')
    simulation.minimizeEnergy()
    print ('done.\n')
    print ('Step 2: Run {} steps before recording statistics...'.format(pre_steps), end='', flush=True)
    simulation.step(pre_steps)
    print ('done.\n')
    # registrate reporter for output
    simulation.reporters = []

    simulation.reporters.append(DCDReporter(traj_dcd_filename, report_interval_dcd))
    simulation.reporters.append(StateDataReporter(stdout, report_interval_stdout, step=True,
                                                  temperature=True, elapsedTime=True))
    simulation.reporters.append(StateDataReporter(csv_filename, report_interval_csv, time=True,
                                                  potentialEnergy=True,
                                                  totalEnergy=True,
                                                  temperature=True))

    # run the simulation
    print ('Step 3: Simulation starts.', flush=True)
    start = time.time()
    simulation.step(n_steps)
    end = time.time()
    print ( 'Simulation ends, %d sec. elapsed.' % (end - start) )

    del simulation

def calc_weights(sys_temp, sampling_temp, csv_filename, traj_weight_filename, energy_col_idx=1):
    r"""Calculate weights of the trajectory data

    Args:
        sys_temp (int): system's true temperature
        sampling_temp (int): temperature used in sampling states
        csv_filename (str): filename of a csv file generated by :meth:`integrate_langevin`
        traj_weight_filename (str): filename to output the trajectory weights
        energy_col_idx (int): column index of the file csv_filename that will be used to calcuate weights

    """

    # use potential energy in the csv file generated by OpenMM code
    print (f'\n=============Calculate Weights============')
    print (f'\nSampling temperature: {sampling_temp}, system temperature: {sys_temp}')
    print (f'Reading potential from: {csv_filename}')
    vec = pd.read_csv(csv_filename)
    # modify the name of the first column
    vec.rename(columns={vec.columns[0]: 'Time (ps)'}, inplace=True)
    # show the data 
    print ('\nWhole data:\n', vec.head(8))

    # select the column containing energy used to calculate weights
    energy_col_name=vec.columns[energy_col_idx]
    print ('\nUse {:d}th column to reweight, name: {}'.format(energy_col_idx, energy_col_name) )

    sampling_beta = 1.0 / (sampling_temp * unit.BOLTZMANN_CONSTANT_kB * unit.AVOGADRO_CONSTANT_NA)
    sys_beta = 1.0 / (sys_temp * unit.BOLTZMANN_CONSTANT_kB * unit.AVOGADRO_CONSTANT_NA)
    energy_list = vec[energy_col_name]
    mean_energy = energy_list.mean()

    print (f'\nsampling beta={sampling_beta}, system beta={sys_beta}')

    # compute weights from potential energy
    nonnormalized_weights = [math.exp(-(sys_beta - sampling_beta) * (energy - mean_energy) * unit.kilojoule_per_mole) for energy in energy_list] 
    weights = pd.DataFrame(nonnormalized_weights / np.mean(nonnormalized_weights), columns=['weight'] )

    # insert time info
    time_col_idx = 0
    time_col_name=vec.columns[time_col_idx]
    weights.insert(0, time_col_name, vec[time_col_name])
    print ('\nWeight:\n', weights.head(8), '\n\nSummary of weights:\n', weights.describe())

    weights.to_csv(traj_weight_filename, index=False)
    print (f'weights saved to: {traj_weight_filename}')

