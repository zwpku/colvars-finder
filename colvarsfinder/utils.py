"""Trajectory Data --- :mod:`colvarsfinder.utils`
=================================================================

:Author: Wei Zhang
:Year: 2022
:Copyright: GNU Public License v3

This module implements the function
:meth:`integrate_langevin` for sampling trajectory data,
the function :meth:`calc_weights` for calculating
weights of the states, and the class :class:`WeightedTrajectory` that holds trajectory information.

Classes
-------
.. autoclass:: WeightedTrajectory
    :members:

Functions
---------

.. autofunction:: integrate_langevin

.. autofunction:: calc_weights

"""


import math
from random import random, randint
import numpy as np
import time
import datetime
import os, sys
import warnings
from sys import stdout
import pandas as pd
import MDAnalysis as mda
import torch

# import openmm
from openmm import *
from openmm.app import *

# ### MD simulation

class WeightedTrajectory(object):
    r"""Class that stores trajectory data.

    Args:
        universe (:external+mdanalysis:class:`MDAnalysis.core.universe.Universe`): a MDAnalysis Universe that contains trajectory data
        weight_filename (str): filename of a CSV file that contains weights of trajectory 
        min_w (float): minimal value of weights below which the corresponding states will be discarded
        max_w (float): maximal value of weights above which the corresponding states will be discarded
        verbose (bool): print more information if ture

    Note:
        Weights will be set to one, if weight_filename is None.


    Example:

        The CSV file containing weights can be generated by running :meth:`integrate_langevin`: 

    .. code-block:: text
        :caption: weights.csv

        Time (ps),weight
        1.9999999999998903,0.8979287896010564
        2.9999999999997806,0.5424829921777613
        3.9999999999996714,0.02360908666276056
        5.000000000000004,0.03124009081426178
        6.000000000000338,0.4012103169413903
        7.000000000000672,0.617590719346622
        8.000000000001005,0.031154032337133607
        9.000000000000451,0.299688734996611
        9.999999999999895,0.03230412279837258
        ...

    Raises:
        ValueError: if trajectory information in the CSV file does not match that in the universe.
      
    Attributes:
        trajectory (3d numpy array): states in the trajectory, shape:
            :math:`[l, n, 3]`, where :math:`l` =n_frames is the number of states, 
            and :math:`n` is the number of atoms of the system
        start_time (float): time of the first state in the trajectory, unit: ps
        dt (float): timestep of the trajectory data, unit: ps
        n_frames (int): number of states in the trajectory
        weights (1d numpy array): weights of states


    """
    def __init__(self, universe, weight_filename=None, min_w=0.0, max_w=float("inf"), verbose=True):

        if verbose: print ('\nloading trajectory to numpy array...', end='') 

        # load trajectory 
        self.trajectory = universe.trajectory.timeseries(order='fac')

        if verbose: print ('done.') 

        self.start_time = universe.trajectory.time
        self.dt = universe.trajectory.dt
        self.n_frames = universe.trajectory.n_frames

        # print information of trajectory
        if verbose: 
            print ('\nTrajectory Info:\n' \
                   '  no. of frames in trajectory data: {}\n' \
                   '  time of first frame: {:.1f}ps\n'\
                   '  time of last frame: {:.1f}ps\n'\
                   '  stepsize: {:.1f}ps\n' \
                   '  time length: {:.1f}ps\n'\
                   '  shape of trajectory data array: {}\n'.format(self.n_frames, 
                                                                   self.start_time, 
                                                                   universe.trajectory[-1].time,
                                                                   self.dt, 
                                                                   universe.trajectory.totaltime,
                                                                   self.trajectory.shape
                                                                )
                  )

        if weight_filename :

            time_weight_vec = pd.read_csv(weight_filename)
            # normalize
            time_weight_vec['weight'] /= time_weight_vec['weight'].mean()

            if verbose: 
                print ('\nloading weights from file: ', weight_filename)
                print ('\nWeights:\n', time_weight_vec['weight'].describe(percentiles=[0.2, 0.4, 0.6, 0.8]))

            if self.start_time - time_weight_vec.iloc[0,0] > 0.01 or self.n_frames != len(time_weight_vec.index) :
                raise ValueError('Time in weight file does match the trajectory data!\n')
            else :
                if verbose: print ('\nCompatibility of weights and trajectory verified.\n')

            selected_idx = (time_weight_vec['weight'] > min_w) & (time_weight_vec['weight'] < max_w)
            weights = time_weight_vec[selected_idx].copy()

            self.trajectory = self.trajectory[selected_idx,:,:]

            weights['weight'] /= weights['weight'].mean()

            if verbose: 
                print ('\nAfter selecting states whose weights are in [{:.3e}, {:.3e}] and renormalization:\n' \
                       '\nShape of trajectory: {}'.format(min_w, max_w, self.trajectory.shape)
                      )
                print ('\nWeights:\n', weights['weight'].describe(percentiles=[0.2, 0.4, 0.6, 0.8]))

            self.weights = weights['weight'].to_numpy()
        else :
            self.weights = np.ones(self.n_frames)

# Generate MD trajectory data using OpenMM 
def integrate_langevin(pdb_filename, n_steps, sampling_temp, sampling_path, pre_steps=0, step_size=1.0 * unit.femtoseconds,
        frictionCoeff=1.0 / unit.picosecond,  traj_dcd_filename='traj.dcd', csv_filename='output.csv', report_interval_dcd=100,
        report_interval_stdout=100, report_interval_csv=100, forcefield=None, plumed_script=None):
    r"""Generate trajectory data using OpenMM by integrating Langevin dynamics 

    Args:
        pdb_filename (str): filename of PDB file
        n_steps (int): number of steps to integrate
        sampling_temp (:external+openmm:class:`openmm.unit.quantity.Quantity`): temperature
            used to sample states, unit: kelvin
        sampling_path (str): directory to save results
        pre_steps (int): number of warm-up steps to run before integrating
        step_size (:external+openmm:class:`openmm.unit.quantity.Quantity`): step-size to integrate, unit: fs
        frictionCoeff (:external+openmm:class:`openmm.unit.quantity.Quantity`): friction
            coefficient in Langevin dynamics, unit: :math:`(\text{ps})^{-1}`
        traj_dcd_filename (str): filename of the DCD file to save trajectory 
        csv_filename (str): filename of the CSV file to store statistics
        report_interval_dcd (int): how often to write trajectory to DCD file
        report_interval_stdout (int): how often to print to stdout
        report_interval_csv (int): how often to write statistics to CSV file 
        forcefield (:external+openmm:class:`openmm.app.forcefield.ForceField`): OpenMM force field used to calculate force
        plumed_script (str): script of plumed commands 

    Note: 
        discuss:
       - OpenMM ForceField('amber14-all.xml') will be used, if forcefield=None
       - Format of the CSV file
       - plumed_script 

    Example:

    .. code-block:: text
        :caption: output.csv

        #"Time (ps)","Potential Energy (kJ/mole)","Total Energy (kJ/mole)","Temperature (K)"
        1.9999999999998905,-20.050460354856185,40.50556969779072,285.61632731254656
        2.9999999999997806,-15.15398066696433,84.48038169480243,469.9317413501974
        3.9999999999996705,15.302661169416211,121.54570823139409,501.1020187082061
        5.000000000000004,12.581352923170044,96.93859523113919,397.87624303095436
        6.000000000000338,-12.222791961491907,69.45248734168707,385.22659570846105
        7.000000000000672,-16.41391301364837,91.95546048082197,511.13097116410677
        8.000000000001005,12.60815636162124,79.3336199461453,314.71484888738695
        ...

    """

    print (f'\nSampling temperature: {sampling_temp}')
    print ( 'Directory to save trajectory ouptuts: %s' % sampling_path)

    # add path to filenames
    traj_dcd_filename = os.path.join(sampling_path, traj_dcd_filename)
    csv_filename=os.path.join(sampling_path, csv_filename)

    # prepare before simulation
    pdb = PDBFile(pdb_filename)

    if forcefield is None :
        forcefield = ForceField('amber14-all.xml')

    system = forcefield.createSystem(pdb.topology, nonbondedCutoff=2*unit.nanometer, constraints=HBonds)

    if plumed_script is not None :
        from openmmplumed import PlumedForce
        print ('plumed script: %s' % plumed_script)
        system.addForce(PlumedForce(plumed_script))

    integrator = LangevinIntegrator(sampling_temp, frictionCoeff, step_size)

    simulation = Simulation(pdb.topology, system, integrator)
    simulation.context.setPositions(pdb.positions)

    platform = simulation.context.getPlatform()
    print ("\nUsing OpenMM platform: %s\n" % platform.getName())

    print ('\nStep 1: Energy minimization...', end='')
    simulation.minimizeEnergy()
    print ('done.\n')
    print ('Step 2: Run {} steps before recording statistics...'.format(pre_steps), end='', flush=True)
    simulation.step(pre_steps)
    print ('done.\n')
    # registrate reporter for output
    simulation.reporters = []

    simulation.reporters.append(DCDReporter(traj_dcd_filename, report_interval_dcd))
    simulation.reporters.append(StateDataReporter(stdout, report_interval_stdout, step=True,
                                                  temperature=True, elapsedTime=True))
    simulation.reporters.append(StateDataReporter(csv_filename, report_interval_csv, time=True,
                                                  potentialEnergy=True,
                                                  totalEnergy=True,
                                                  temperature=True))

    # run the simulation
    print ('Step 3: Simulation starts.', flush=True)
    start = time.time()
    simulation.step(n_steps)
    end = time.time()
    print ( 'Simulation ends, %d sec. elapsed.' % (end - start) )

    del simulation

def calc_weights(sys_temp, sampling_temp, csv_filename, traj_weight_filename, energy_col_idx=1):
    r"""Calculate weights of the trajectory data

    Args:
        sys_temp (:external+openmm:class:`openmm.unit.quantity.Quantity`): system's true temperature, unit: kelvin
        sampling_temp (:external+openmm:class:`openmm.unit.quantity.Quantity`): temperature
            used to sample states, unit: kelvin
        csv_filename (str): filename of a csv file generated by :meth:`integrate_langevin`
        traj_weight_filename (str): filename to output the trajectory weights
        energy_col_idx (int): column index of the file csv_filename that will be used to calcuate weights

    Example:

    .. code-block:: python

    """

    # use potential energy in the csv file generated by OpenMM code
    print (f'\n=============Calculate Weights============')
    print (f'\nSampling temperature: {sampling_temp}, system temperature: {sys_temp}')
    print (f'Reading potential from: {csv_filename}')
    vec = pd.read_csv(csv_filename)
    # modify the name of the first column
    vec.rename(columns={vec.columns[0]: 'Time (ps)'}, inplace=True)
    # show the data 
    print ('\nWhole data:\n', vec.head(8))

    # select the column containing energy used to calculate weights
    energy_col_name=vec.columns[energy_col_idx]
    print ('\nUse {:d}th column to reweight, name: {}'.format(energy_col_idx, energy_col_name) )

    sampling_beta = 1.0 / (sampling_temp * unit.BOLTZMANN_CONSTANT_kB * unit.AVOGADRO_CONSTANT_NA)
    sys_beta = 1.0 / (sys_temp * unit.BOLTZMANN_CONSTANT_kB * unit.AVOGADRO_CONSTANT_NA)
    energy_list = vec[energy_col_name]
    mean_energy = energy_list.mean()

    print (f'\nsampling beta={sampling_beta}, system beta={sys_beta}')

    # compute weights from potential energy
    nonnormalized_weights = [math.exp(-(sys_beta - sampling_beta) * (energy - mean_energy) * unit.kilojoule_per_mole) for energy in energy_list] 
    weights = pd.DataFrame(nonnormalized_weights / np.mean(nonnormalized_weights), columns=['weight'] )

    # insert time info
    time_col_idx = 0
    time_col_name=vec.columns[time_col_idx]
    weights.insert(0, time_col_name, vec[time_col_name])
    print ('\nWeight:\n', weights.head(8), '\n\nSummary of weights:\n', weights.describe())

    weights.to_csv(traj_weight_filename, index=False)
    print (f'weights saved to: {traj_weight_filename}')



