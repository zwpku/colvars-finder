# Generate MD trajectory data using OpenMM 
import math
from random import random, randint
import numpy as np
import time
import datetime
import os, sys
import warnings
from sys import stdout
import pandas as pd

# import openmm
from openmm import *
from openmm.app import *

# ### MD simulation

def LangevinSampler(pdb_filename, n_steps, sampling_temp, sampling_path, pre_steps=0, step_size=1.0 * unit.femtoseconds,
        frictionCoeff=1.0 / unit.picosecond,  traj_dcd_filename='traj.dcd', csv_filename='output.csv', report_interval_dcd=100,
        report_interval_stdout=100, report_interval_csv=100, forcefield=None, plumed_script=None):

    print (f'\nSampling temperature: {sampling_temp}')
    print ( 'Directory to save trajectory ouptuts: %s' % sampling_path)

    # add path to filenames
    traj_dcd_filename = os.path.join(sampling_path, traj_dcd_filename)
    csv_filename=os.path.join(sampling_path, csv_filename)

    # prepare before simulation
    pdb = PDBFile(pdb_filename)

    if forcefield is None :
        forcefield = ForceField('amber14-all.xml')

    system = forcefield.createSystem(pdb.topology, nonbondedCutoff=2*unit.nanometer, constraints=HBonds)

    if plumed_script is not None :
        from openmmplumed import PlumedForce
        print ('plumed script: %s' % plumed_script)
        system.addForce(PlumedForce(plumed_script))

    integrator = LangevinIntegrator(sampling_temp, frictionCoeff, step_size)

    simulation = Simulation(pdb.topology, system, integrator)
    simulation.context.setPositions(pdb.positions)

    platform = simulation.context.getPlatform()
    print ("\nUsing OpenMM platform: %s\n" % platform.getName())

    print ('\nStep 1: Energy minimization...', end='')
    simulation.minimizeEnergy()
    print ('done.\n')
    print ('Step 2: Run {} steps before recording statistics...'.format(pre_steps), end='', flush=True)
    simulation.step(pre_steps)
    print ('done.\n')
    # registrate reporter for output
    simulation.reporters = []

    simulation.reporters.append(DCDReporter(traj_dcd_filename, report_interval_dcd))
    simulation.reporters.append(StateDataReporter(stdout, report_interval_stdout, step=True,
                                                  temperature=True, elapsedTime=True))
    simulation.reporters.append(StateDataReporter(csv_filename, report_interval_csv, time=True,
                                                  potentialEnergy=True,
                                                  totalEnergy=True,
                                                  temperature=True))

    # run the simulation
    print ('Step 3: Simulation starts.', flush=True)
    start = time.time()
    simulation.step(n_steps)
    end = time.time()
    print ( 'Simulation ends, %d sec. elapsed.' % (end - start) )

    del simulation

def calc_weights(sys_temp, sampling_temp, csv_filename, traj_weight_filename, energy_col_idx=1):

    # use potential energy in the csv file generated by OpenMM code
    print (f'\n=============Calculate Weights============')
    print (f'\nSampling temperature: {sampling_temp}, system temperature: {sys_temp}')
    print (f'Reading potential from: {csv_filename}')
    vec = pd.read_csv(csv_filename)
    # modify the name of the first column
    vec.rename(columns={vec.columns[0]: 'Time (ps)'}, inplace=True)
    # show the data 
    print ('\nWhole data:\n', vec.head(8))

    # select the column containing energy used to calculate weights
    energy_col_name=vec.columns[energy_col_idx]
    print ('\nUse {:d}th column to reweight, name: {}'.format(energy_col_idx, energy_col_name) )

    sampling_beta = 1.0 / (sampling_temp * unit.BOLTZMANN_CONSTANT_kB * unit.AVOGADRO_CONSTANT_NA)
    sys_beta = 1.0 / (sys_temp * unit.BOLTZMANN_CONSTANT_kB * unit.AVOGADRO_CONSTANT_NA)
    energy_list = vec[energy_col_name]
    mean_energy = energy_list.mean()

    print (f'\nsampling beta={sampling_beta}, system beta={sys_beta}')

    # compute weights from potential energy
    nonnormalized_weights = [math.exp(-(sys_beta - sampling_beta) * (energy - mean_energy) * unit.kilojoule_per_mole) for energy in energy_list] 
    weights = pd.DataFrame(nonnormalized_weights / np.mean(nonnormalized_weights), columns=['weight'] )

    # insert time info
    time_col_idx = 0
    time_col_name=vec.columns[time_col_idx]
    weights.insert(0, time_col_name, vec[time_col_name])
    print ('\nWeight:\n', weights.head(8), '\n\nSummary of weights:\n', weights.describe())

    weights.to_csv(traj_weight_filename, index=False)
    print (f'weights saved to: {traj_weight_filename}')

#/
